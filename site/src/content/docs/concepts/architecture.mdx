---
title: Architecture
description: How reklawdbox connects to Rekordbox, external services, and your MCP host.
sidebar:
  order: 1
---

import { Aside, Steps, Tabs, Card, CardGrid } from '@astrojs/starlight/components';

## System overview

reklawdbox is a single Rust binary (~8.5 MB, arm64). It runs as an MCP server communicating with your host (Claude Code, Claude Desktop, Codex) over stdio. Everything ships in one binary — no runtime dependencies except an optional Python venv for Essentia.

Key components:

- **MCP server** — accepts tool calls over stdio, returns structured JSON responses
- **SQLCipher reader** — opens the encrypted Rekordbox `master.db` read-only via rusqlite with bundled SQLCipher and OpenSSL
- **Internal SQLite** — separate database (WAL mode) for enrichment cache, audio analysis cache, and broker session tokens
- **HTTP client** — reqwest + rustls for Discogs broker and Beatport requests
- **Audio analysis** — symphonia for decoding, stratum-dsp for BPM/key detection (embedded in binary)
- **Essentia** — optional Python subprocess for advanced audio descriptors

## Data flow

```
MCP Host (Claude Code / Claude Desktop / Codex)
  │
  │  stdio (JSON-RPC)
  ▼
reklawdbox (single Rust binary)
  ├── Rekordbox master.db ──── read-only, SQLCipher encrypted
  ├── Internal SQLite ──────── cache: enrichment, audio analysis, broker sessions
  ├── Discogs broker ───────── Cloudflare Workers + D1 (OAuth proxy)
  ├── Beatport ─────────────── HTML/JSON extraction (no API key needed)
  ├── stratum-dsp ──────────── embedded Rust audio analysis (BPM, key)
  ├── Essentia ─────────────── optional Python subprocess (energy, danceability)
  └── XML output ───────────── Rekordbox-compatible export files
```

## Rekordbox database

Rekordbox 6 and 7 encrypt `master.db` with SQLCipher 4 (AES-256-CBC). The encryption key is universal — the same for every installation. reklawdbox bundles SQLCipher and handles decryption transparently.

### Key tables

| Table | Purpose |
|-------|---------|
| `DjmdContent` | Every track in your collection. Title, ArtistID, GenreID, BPM (integer x100), KeyID, Rating, `Commnt` (not a typo — that is the actual column name) |
| `djmdArtist` | Artist names. FK from `DjmdContent.ArtistID` |
| `djmdAlbum` | Album names. FK from `DjmdContent.AlbumID` |
| `djmdGenre` | Genre names. FK from `DjmdContent.GenreID` |
| `djmdKey` | Musical key names. FK from `DjmdContent.KeyID` |
| `djmdLabel` | Record label names |
| `djmdColor` | Color tag names. FK from `DjmdContent.ColorID` |
| `djmdPlaylist` | Playlists and folders. Type 0 = playlist, 1 = folder, 4 = smart playlist |
| `djmdSongPlaylist` | Track-to-playlist membership (join table) |

<Aside type="note">
  All primary keys are `VARCHAR(255)` strings, not integers. This is an unusual schema choice by Pioneer but reklawdbox handles it transparently.
</Aside>

### BPM encoding

Rekordbox stores BPM as an integer with two implied decimal places. A track at 128.50 BPM is stored as `12850`. reklawdbox converts this to a float automatically when returning track data.

## Discogs broker

The Discogs broker is a companion service written in TypeScript, deployed on Cloudflare Workers with D1 (SQLite) for storage. It acts as an OAuth proxy — your reklawdbox instance never holds Discogs consumer secrets or user tokens directly.

### Authentication flow

<Steps>

1. You call `lookup_discogs` for any track. The broker checks if you have an active session.

2. If not authenticated, the broker returns an OAuth authorization URL. Open it in your browser.

3. After you approve access on Discogs, the broker stores your OAuth token in D1 and returns a broker session token to reklawdbox.

4. reklawdbox stores the broker session token in its internal SQLite. All subsequent `lookup_discogs` calls use this token automatically.

</Steps>

The broker session token is stored locally at the internal SQLite path. If you delete the internal database, you will need to re-authorize.

<Aside type="tip">
  The broker is open-source and self-hostable. Set `REKLAWDBOX_DISCOGS_BROKER_URL` and `REKLAWDBOX_DISCOGS_BROKER_TOKEN` to point at your own deployment.
</Aside>

## Audio analysis pipeline

reklawdbox has two analysis backends that serve different purposes.

### stratum-dsp (always available)

stratum-dsp is a Rust library embedded directly in the reklawdbox binary. It provides:

- **BPM detection** — tempo estimation from audio
- **Key detection** — musical key mapped to Camelot notation

stratum-dsp runs on every `analyze_track_audio` call. No setup required.

### Essentia (optional, Python subprocess)

Essentia adds advanced audio descriptors that stratum-dsp does not cover:

- **Danceability** — rhythmic regularity and beat strength
- **Rhythm regularity** — how consistent the rhythmic pattern is
- **Spectral centroid** — brightness/timbre (higher = brighter sound)
- **Loudness (integrated)** — perceived loudness in LUFS
- **Onset rate** — transient density (higher = more percussive)
- **Dynamic complexity** — loudness range over time

Essentia runs as a Python subprocess. It requires a virtual environment with the `essentia` package installed. See [Getting Started](/getting-started/) for setup instructions.

<Aside type="note">
  Essentia results are used for energy computation and the brightness/rhythm axes in transition scoring. Without Essentia, energy falls back to a BPM-based proxy and those axes score at a neutral 0.5.
</Aside>

### Caching

Both backends cache their results in the internal SQLite database, keyed by file path and analyzer name. Analysis only runs once per track per backend. Use `skip_cached: false` in `analyze_track_audio` to force a re-analysis if needed.

## CLI subcommands

reklawdbox has additional modes beyond the MCP server. The binary supports these subcommands:

| Subcommand | Purpose |
|------------|---------|
| *(default)* | Start the MCP server (stdio). This is what your MCP host launches. |
| `analyze` | Batch audio analysis with filters. Analyze your entire collection or a filtered subset without going through MCP. |
| `read-tags` | Read native file tags (ID3, Vorbis, etc.) from audio files. |
| `write-tags` | Write native file tags to audio files. |
| `extract-art` | Extract embedded cover art from audio files. |
| `embed-art` | Embed cover art into audio files. |

The CLI subcommands operate directly on files and do not require an MCP host. They are useful for batch operations and scripting.

```bash
# Batch-analyze all tracks matching a filter
./reklawdbox analyze --genre "Techno" --limit 50

# Read tags from a file
./reklawdbox read-tags /path/to/track.flac

# Extract cover art
./reklawdbox extract-art /path/to/track.mp3 --output cover.jpg
```

<CardGrid>
  <Card title="Concepts Overview" icon="open-book">
    Core design principles: read-only access, staging, XML export.
    [Back to overview](/concepts/)
  </Card>
  <Card title="Harmonic Mixing" icon="star">
    How reklawdbox uses the Camelot wheel and audio features to score transitions.
    [Read more](/concepts/harmonic-mixing/)
  </Card>
</CardGrid>
